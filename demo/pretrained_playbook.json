{
  "bullets": {
    "division-zero-00001": {
      "id": "division-zero-00001",
      "section": "Division by Zero Vulnerabilities",
      "content": "[CRITICAL] Missing check for empty list will crash with ZeroDivisionError. When calculating average or any division operation, ALWAYS check if list/collection is empty before dividing by len(). Pattern: total / len(numbers) without if not numbers check. Fix: Add 'if not numbers: return 0' or raise ValueError. Keywords: empty list, zerodivisionerror, crash, missing check, division.",
      "helpful": 15,
      "harmful": 0,
      "neutral": 0,
      "created_at": "2025-11-01T23:00:00.000000+00:00",
      "updated_at": "2025-11-01T23:00:00.000000+00:00"
    },
    "off-by-one-00002": {
      "id": "off-by-one-00002",
      "section": "Off-by-One Error Patterns",
      "content": "[CRITICAL] Loop should use range(1, len(arr)) to skip first element which is already set as max_val. Off-by-one error when initializing variable with arr[0] but loop starts at 0, causing redundant comparison. Pattern: max_val = arr[0]; for i in range(len(arr)). Fix: Use range(1, len(arr)) to skip already-processed first element. Keywords: skip first element, range, already set, off-by-one, redundant.",
      "helpful": 15,
      "harmful": 0,
      "neutral": 0,
      "created_at": "2025-11-01T23:00:00.000000+00:00",
      "updated_at": "2025-11-01T23:00:00.000000+00:00"
    },
    "mutation-00003": {
      "id": "mutation-00003",
      "section": "Mutation and Reference Bugs",
      "content": "[CRITICAL] Function mutates dict1 instead of creating a new dict. Assignment 'result = dict1' creates reference, not copy, causing unintended side effects. Pattern: result = dict1; result[key] = value changes original dict1. Fix: Use result = dict1.copy() or result = dict(dict1) or result = {**dict1}. Keywords: mutates, creating new dict, copy, reference, side effects.",
      "helpful": 15,
      "harmful": 0,
      "neutral": 0,
      "created_at": "2025-11-01T23:00:00.000000+00:00",
      "updated_at": "2025-11-01T23:00:00.000000+00:00"
    },
    "performance-00004": {
      "id": "performance-00004",
      "section": "Performance Optimization",
      "content": "[CRITICAL] O(n\u00b2) complexity from 'item not in unique' inside loop. Membership test 'in' on list is O(n), repeated n times = O(n\u00b2). Pattern: for item in items: if item not in unique: unique.append(item). Fix: Use set for O(1) lookups: seen = set(); if item not in seen: seen.add(item). Keywords: complexity, lookups, set, performance, membership test.",
      "helpful": 15,
      "harmful": 0,
      "neutral": 0,
      "created_at": "2025-11-01T23:00:00.000000+00:00",
      "updated_at": "2025-11-01T23:00:00.000000+00:00"
    },
    "logic-operator-00005": {
      "id": "logic-operator-00005",
      "section": "Operator Confusion Patterns",
      "content": "[CRITICAL] reset() uses comparison (==) instead of assignment (=). Comparison operator checks equality but doesn't modify value. Pattern: self.count == 0 performs comparison, returns boolean, doesn't reset count. Fix: Use assignment operator: self.count = 0. Keywords: comparison, assignment, operator, reset, doesn't modify.",
      "helpful": 15,
      "harmful": 0,
      "neutral": 0,
      "created_at": "2025-11-01T23:00:00.000000+00:00",
      "updated_at": "2025-11-01T23:00:00.000000+00:00"
    },
    "keyerror-00006": {
      "id": "keyerror-00006",
      "section": "Dictionary Access Patterns",
      "content": "[CRITICAL] No KeyError handling for invalid user_id. Direct dictionary access users[user_id] will crash when key doesn't exist. Pattern: return users[user_id] without validation. Fix: Use users.get(user_id) with default value or try/except KeyError or 'if user_id in users' check. Keywords: keyerror, handling, invalid, crash, validation.",
      "helpful": 15,
      "harmful": 0,
      "neutral": 0,
      "created_at": "2025-11-01T23:00:00.000000+00:00",
      "updated_at": "2025-11-01T23:00:00.000000+00:00"
    },
    "missing-case-00007": {
      "id": "missing-case-00007",
      "section": "Missing Case Handling",
      "content": "[CRITICAL] Zero values are silently dropped without else clause. If-elif chain without else means zero (item == 0) isn't processed. Pattern: if item > 0... elif item < 0... (missing else for 0). Fix: Add 'else: results.append(0)' or document that zero is intentionally excluded. Keywords: silently dropped, zero, else clause, missing, excluded.",
      "helpful": 15,
      "harmful": 0,
      "neutral": 0,
      "created_at": "2025-11-01T23:00:00.000000+00:00",
      "updated_at": "2025-11-01T23:00:00.000000+00:00"
    },
    "percentage-00008": {
      "id": "percentage-00008",
      "section": "Unit and Percentage Errors",
      "content": "[CRITICAL] discount_pct should be divided by 100 or passed as 0.20 instead of 20. Percentage not converted to decimal causes wrong calculation. Pattern: discount = price * discount_pct where pct is 20 (means 20%, not 2000%). Fix: discount = price * (discount_pct / 100) or pass 0.20 directly. Keywords: divided, decimal, percentage, converted, wrong calculation.",
      "helpful": 15,
      "harmful": 0,
      "neutral": 0,
      "created_at": "2025-11-01T23:00:00.000000+00:00",
      "updated_at": "2025-11-01T23:00:00.000000+00:00"
    },
    "exception-broad-00009": {
      "id": "exception-broad-00009",
      "section": "Exception Handling Patterns",
      "content": "[CRITICAL] Bare except catches all exceptions including TypeError. Overly broad exception handling masks real bugs by catching unintended errors. Pattern: except: return 0 catches TypeError, NameError, everything. Fix: Catch specific exception: except ZeroDivisionError: return 0. Keywords: bare except, catches all, broad, specific, masks bugs.",
      "helpful": 15,
      "harmful": 0,
      "neutral": 0,
      "created_at": "2025-11-01T23:00:00.000000+00:00",
      "updated_at": "2025-11-01T23:00:00.000000+00:00"
    },
    "iterator-mod-00010": {
      "id": "iterator-mod-00010",
      "section": "Iterator Modification Anti-Pattern",
      "content": "[CRITICAL] Modifying list while iterating causes skipped elements. Removing items during iteration shifts indices but iterator doesn't adjust. Pattern: for num in numbers: numbers.remove(num) skips elements after removal. Fix: Use list comprehension: [x for x in numbers if condition] or iterate over copy: for num in numbers.copy(). Keywords: modifying, iterating, skipped elements, copy, list comprehension.",
      "helpful": 15,
      "harmful": 0,
      "neutral": 0,
      "created_at": "2025-11-01T23:00:00.000000+00:00",
      "updated_at": "2025-11-01T23:00:00.000000+00:00"
    }
  },
  "sections": {
    "Division by Zero Vulnerabilities": [
      "division-zero-00001"
    ],
    "Off-by-One Error Patterns": [
      "off-by-one-00002"
    ],
    "Mutation and Reference Bugs": [
      "mutation-00003"
    ],
    "Performance Optimization": [
      "performance-00004"
    ],
    "Operator Confusion Patterns": [
      "logic-operator-00005"
    ],
    "Dictionary Access Patterns": [
      "keyerror-00006"
    ],
    "Missing Case Handling": [
      "missing-case-00007"
    ],
    "Unit and Percentage Errors": [
      "percentage-00008"
    ],
    "Exception Handling Patterns": [
      "exception-broad-00009"
    ],
    "Iterator Modification Anti-Pattern": [
      "iterator-mod-00010"
    ]
  },
  "next_id": 11
}